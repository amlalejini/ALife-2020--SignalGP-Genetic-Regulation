---
title: "Demonstrating Genetic Regulation in SignalGP - Analysis - Changing Signal Task"
output: 
  html_document: 
    keep_md: no
    toc: true
    toc_float: true
    toc_depth: 4
    collapsed: false
    theme: default
    code_folding: hide
  pdf_document:
    toc: true
    toc_depth: 4
---

## Overview

## Dependencies

Load all required R libraries.

```{r, message=FALSE}
library(ggplot2)  # (Wickham, 2009)
library(dplyr)    # (Wickham et al., 2018)
library(cowplot)  # (Wilke, 2018)
library(viridis)  # (Garnier, 2018)
```

## Setup

Load data, initial data cleanup, global settings.

```{r}
data_loc <- "../data/chg-env/rd2/max_fit_orgs.csv"
data <- read.csv(data_loc, na.strings="NONE")
# data <- subset(data, select = -c(program))

# Specify factors.
data$matchbin_thresh <- factor(data$matchbin_thresh,
                                     levels=c(0, 25, 50, 75))
data$NUM_ENV_STATES <- factor(data$NUM_ENV_STATES,
                                    levels=c(2, 4, 8, 16, 32))
data$NUM_ENV_UPDATES <- factor(data$NUM_ENV_UPDATES,
                              levels=c(2, 4, 8, 16, 32))
data$TAG_LEN <- factor(data$TAG_LEN,
                       levels=c(32, 64, 128))
# Define function to summarize regulation/memory configurations.
get_con <- function(reg, mem) {
  if (reg == "0" && mem == "0") {
    return("none")
  } else if (reg == "0" && mem=="1") {
    return("memory")
  } else if (reg=="1" && mem=="0") {
    return("regulation")
  } else if (reg=="1" && mem=="1") {
    return("both")
  } else {
    return("UNKNOWN")
  }
}
# Specify experimental condition for each datum.
data$condition <- mapply(get_con, data$USE_FUNC_REGULATION, data$USE_GLOBAL_MEMORY)
data$condition <- factor(data$condition, levels=c("regulation", "memory", "none", "both"))


# Settings for statistical analyses.
alpha <- 0.05
correction_method <- "bonferroni"
```

## solutions

### Number of evolved solutions per condition

An organism is categorized as a 'solution' if it can correctly respond in each of the $K$ environment states.

```{r, echo=TRUE}

label_lu <- c(
  "2" = "Environments: 2", 
  "4" = "Environments: 4", 
  "8" = "Environments: 8", 
  "16" = "Environments: 16", 
  "32" ="Environments: 32"
)


sol_data <- filter(data, solution=="1")
ggplot(sol_data, aes(x=condition, fill=condition)) +
  geom_bar() +
  geom_text(stat="count", aes(label=..count..), position=position_dodge(0.9), vjust=0) +
  ggtitle("Solution Counts by Condition and Environment Complexity") +
  xlab("Condition") +
  ylab("# Evolved Solutions") +
  ylim(0, 100) 
  # facet_wrap(~ NUM_ENV_STATES, labeller=labeller(NUM_ENV_STATES=label_lu)) +
  # ggsave("./imgs/changing-signal-solultion-cnts.png", width=16,height=8)

ggplot(filter(sol_data, all_solution=="1"), aes(x=condition, fill=condition)) +
  geom_bar() +
  geom_text(stat="count", aes(label=..count..), position=position_dodge(0.9), vjust=0) +
  ggtitle("Solution Counts by Condition and Environment Complexity") +
  xlab("Condition") +
  ylab("# Evolved Solutions") +
  ylim(0, 100) 
  # facet_wrap(~ NUM_ENV_STATES, labeller=labeller(NUM_ENV_STATES=label_lu)) +
  # ggsave("./imgs/changing-signal-solultion-cnts.png", width=16,height=8)
  
ggplot(filter(sol_data, all_solution_ko_reg=="1"), aes(x=condition, fill=condition)) +
  geom_bar() +
  geom_text(stat="count", aes(label=..count..), position=position_dodge(0.9), vjust=0) +
  ggtitle("Solution Counts by Condition and Environment Complexity") +
  xlab("Condition") +
  ylab("# Evolved Solutions") +
  ylim(0, 100) 
  # facet_wrap(~ NUM_ENV_STATES, labeller=labeller(NUM_ENV_STATES=label_lu)) +
  # ggsave("./imgs/changing-signal-solultion-cnts.png", width=16,height=8)
```

### scores by condition

Here, we give the raw task scores for the highest-fitness organism from each run across all environments/conditions.

```{r}
ggplot(data, aes(x=condition, y=score, color=condition)) +
  geom_boxplot() +
  ggtitle("Scores by Condition and Environment Complexity") +
  xlab("Condition") +
  ylab("Score (# correct responses)") +
  scale_color_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global Memory", "Neither", "Both")) +
  scale_x_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global\nMemory", "Neither", "Both")) +
  facet_wrap(~ NUM_ENV_STATES, scales="free_y", labeller=labeller(NUM_ENV_STATES=label_lu)) +
  ggsave("./imgs/changing-signal-scores.png", width=16,height=8)
```

### How long did it take for solutions to arise?

```{r}
ggplot(filter(data, solution=="1"), aes(x=condition, y=update, color=condition)) +
  geom_boxplot() +
  ggtitle("Time to solution") +
  xlab("Condition") +
  ylab("Generation of first solution") +
  scale_color_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global Memory", "Neither", "Both")) +
  scale_x_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global\nMemory", "Neither", "Both")) +
  facet_wrap(~ NUM_ENV_STATES, scales="free_y", labeller=labeller(NUM_ENV_STATES=label_lu)) +
  ggsave("./imgs/changing-signal-solve-time.png", width=16,height=8)
```


```{r}
# Make comparison of time to solution fair

# Rank by condition

envs <- c(2, 4, 8, 16)
ranked_data <- data.frame()
for (env in envs) {
  none_data <- filter(data, condition=="none" & NUM_ENV_STATES==env)
  none_data$rank <- rank(none_data$update, ties="random")
  
  mem_data <- filter(data, condition=="memory" & NUM_ENV_STATES==env)
  mem_data$rank <- rank(mem_data$update, ties="random")
  
  reg_data <- filter(data, condition=="regulation" & NUM_ENV_STATES==env)
  reg_data$rank <- rank(reg_data$update, ties="random")
  
  both_data <- filter(data, condition=="both" & NUM_ENV_STATES==env)
  both_data$rank <- rank(both_data$update, ties="random")  
  
  ranked_data <- rbind(ranked_data, none_data, mem_data, reg_data, both_data)
}

ggplot(filter(ranked_data, solution=="1" & rank<=25), aes(x=condition, y=update, color=condition)) +
  geom_boxplot() +
  ggtitle("Time to solution") +
  xlab("Condition") +
  ylab("Generation of first solution") +
  scale_color_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global Memory", "Neither", "Both")) +
  scale_x_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global\nMemory", "Neither", "Both")) +
  facet_wrap(~ NUM_ENV_STATES, scales="free_y", labeller=labeller(NUM_ENV_STATES=label_lu)) +
  ggsave("./imgs/changing-signal-solve-time.png", width=16,height=8)

```


#### 2-state environment

All identical

#### 4-state environment

```{r}
env_4_sol_data <- filter(data, solution=="1" & NUM_ENV_STATES==4)
# First, kruskal-wallis to test for significant differences among groups
env4_kt <- kruskal.test(update ~ condition, data=env_4_sol_data)
print(env4_kt)
# Next, if kruskal-wallis is significant, perform a pairwise wilcoxon rank-sum test
if (env4_kt$p.value < alpha) {
  # x: response vector; g: grouping vector
  env4_wt <- pairwise.wilcox.test(x=env_4_sol_data$update, g=env_4_sol_data$condition, p.adjust.method="holm", exact=FALSE)
  print(env4_wt)
} else {
  print("No significant difference.")
}
```

#### 8-state environment

```{r}
env_8_sol_data <- filter(data, solution=="1" & NUM_ENV_STATES==8)
# First, kruskal-wallis to test for significant differences among groups
env8_kt <- kruskal.test(update ~ condition, data=env_8_sol_data)
print(env8_kt)
# Next, if kruskal-wallis is significant, perform a pairwise wilcoxon rank-sum test
if (env8_kt$p.value < alpha) {
  # x: response vector; g: grouping vector
  env8_wt <- pairwise.wilcox.test(x=env_8_sol_data$update, g=env_8_sol_data$condition, p.adjust.method="holm", exact=FALSE)
  print(env8_wt)
} else {
  print("No significant difference.")
}
```


#### 16-state environment

```{r, echo=TRUE}
# First, kruskal-wallis to test for significant differences among groups
env_16_sol_data <- filter(data, solution=="1" & NUM_ENV_STATES==16)
env16_kt <- kruskal.test(update ~ condition, data=env_16_sol_data)
print(env16_kt)
# Next, if kruskal-wallis is significant, perform a pairwise wilcoxon rank-sum test
if (env16_kt$p.value < alpha) {
  # x: response vector; g: grouping vector
  env16_wt <- pairwise.wilcox.test(x=env_16_sol_data$update, g=env_16_sol_data$condition, p.adjust.method="holm", exact=FALSE)
  print(env16_wt)
} else {
  print("No significant difference.")
}
```

### When given access to function regulation and global memory, what do solutions rely on?

```{r}
reg_and_mem_solutions <- filter(data, solution=="1")
get_strategy <- function(use_reg, use_mem) {
  if (use_reg=="0" && use_mem=="0") {
    return("use neither")
  } else if (use_reg=="0" && use_mem=="1") {
    return("use memory")
  } else if (use_reg=="1" && use_mem=="0") {
    return("use regulation")
  } else if (use_reg=="1" && use_mem=="1") {
    return("use both")
  } else {
    return("UNKNOWN")
  }
}
# Specify experimental conditions (to make labeling easier).
reg_and_mem_solutions$strategy <- mapply(get_strategy, reg_and_mem_solutions$relies_on_regulation, reg_and_mem_solutions$relies_on_global_memory)
reg_and_mem_solutions$strategy <- factor(reg_and_mem_solutions$strategy, levels=c("use regulation", "use memory", "use neither", "use both"))

ggplot(reg_and_mem_solutions, mapping=aes(x=NUM_ENV_STATES, fill=strategy)) +
  geom_bar(position="fill", stat="count") +
  geom_text(stat='count', mapping=aes(label=..count..), position=position_fill(vjust=-0.03)) +
  ylab("% of Solutions") +
  xlab("Environmental Complexity (number of environments)") +
  scale_fill_discrete(limits=c("use regulation", "use memory", "use neither", "use both"),
                   labels=c("Use regulation (only)", "Use global memory (only)", "Use neither", "Use both")) +
  facet_wrap(~condition)
```


### Are evolved programs relying on stochastic strategies?


```{r}
label_lu <- c(
  "2" = "Environments: 2", 
  "4" = "Environments: 4", 
  "8" = "Environments: 8", 
  "16" = "Environments: 16", 
  "32" ="Environments: 32"
)

ggplot(filter(data), aes(x=condition, y=stochastic, fill=condition)) +
  geom_bar(stat="identity") +
  ggtitle("Stochastic Strategies by Condition and Environment Complexity") +
  xlab("Condition") +
  ylab("# Stochastic Strategies") +
  ylim(0, 50) +
  scale_fill_discrete(name="Condition",
                      breaks=c("regulation", "memory", "none", "both"),
                      labels=c("Regulation", "Global Memory", "Neither", "Both")) +
  scale_x_discrete(breaks=c("regulation", "memory", "none", "both"),
                   labels=c("Regulation", "Global\nMemory", "Neither", "Both")) +
  facet_wrap(~ NUM_ENV_STATES, labeller=labeller(NUM_ENV_STATES=label_lu))
```

## Case Study: regulation in action

Next, we take a closer look at the behavioral profile of evolved SignalGP organisms.

Coming soon...
